# 🔑 키워드 정리

## HTTP 자격증명 헤더

### WWW-Authenticate 헤더

서버가 클라이언트에게 인증이 필요함을 알리는 헤더

### Authorization 헤더

클라이언트가 서버에 자신을 인증하기 위해 필요한 정보를 제공하는 헤더

## Bearer Token

1. 서버로부터 액세스 토큰을 획득
2. 토큰을 `Authorization`  헤더에 포함하여 리소스에 접근 요청을 보냄
3. 서버에서 인증 처리

## JSON Web Token (JWT)

### JWT 구조 (Header, Payload, Signature)

- 헤더
  - 토큰의 유형, 서명 알고리즘을 정의
- 페이로드
  - 토큰에 담길 정보 (클레임)을 포함 
    → 클레임은 토큰 사용자에 관한 정보나 추가 메타데이터를 담을 수 있다
- 서명
    - 헤더와 페이로드를 합친 후, 지정된 알고리즘 (HS256)으로 해시하고 비밀키를 사용하여 서명한 결과

### JWT 서명 및 암호화 (HMAC, RSA, ECDSA)

1. HMAC (대칭키)
    - 같은 비밀키를 사용하여 서명과 검증을 수행
2. RSA/ECDSA (비대칭 키 방식)
    - 개인키로 서명하고, 공개키로 검증
    - 보안성이 더 높지만, 성능이 다소 낮음

### 세션 기반 인증과의 비교

|  | JWT | 세션 기반 |
| --- | --- | --- |
| 서버 저장소 | 필요 없음 | 필요함 |
| 확장성 | 뛰어남 | 낮음 (세션 저장소 관리 필요) |
| 인증 정보 저장 | 클라이언트의 토큰 내 포함 | 서버의 세션 저장소에 저장 |
| 성능 | 빠름 (DB 조회 불필요) | 상대적으로 느림 (세션 조회 필요) |
| 보안 | 토큰 탈취 시 위험 | 서버에서 세션 관리 가능 |
| 쿠키 사용 | 불필요 | 필요 |

## Access Token / Refresh Token

### **Access Token**

- 리소스에 접근할 수 있는 권한을 증명
- 짧은 유효기간
- JWT 형태
- 주로 Authorization 헤더에 포함되어 전송

### **Refresh Token**

- 새로운 Access Token을 발급받을 때 사용
- 긴 유효기간
- 서버의 DB에 저장되어 관리

## OAuth 2.0

OAuth 2.0은 타사 애플리케이션이 사용자 비밀번호를 직접 제공받지 않고도, 안전하게 사용자 리소스에 접근할 수 있도록 하는 인증 및 권한 부여 프레임워크

- 소셜 로그인 및 API 인증에 사용
- 토큰 기반 인증 방식을 사용하여 액세스 토큰을 통해 권한을 위임
- 클라이언트 앱이 사용자의 로그인 정보 없이 API를 호출할 수 있도록 지원

### OAuth 1.0과의 차이점

|  | OAuth 1.0 | OAuth 2.0 |
| --- | --- | --- |
| 토큰 유형 | 서명 기반 토큰 | 액세스 토큰 |
| 보안 방식 | 요청마다 서명 필요 | HTTPS 기반 보안 |
| 인증 방식 | 복잡한 프로세스 | 간소화된 인증 |
| 사용성 | 어렵고 복잡함 | 쉬운 구현, 다양한 인증 방식 제공 |
| 권한 위임 방식 | 사용자 서명을 포함 | 액세스 토큰을 통한 권한 위임 |
| 확장성 | 낮음 | 높음 |

## 보안 강화 대책 (XSS, CSRF, 토큰 탈취 방지)

1. XSS
    1. 정의 : 공격자가 악성 스크립트를 삽입하여 사용자의 브라우저에서 실행되도록 하는 공격
    2. 방지 대책
        - 입력값 검증
        - 출력값 인코딩
2. CSRF
    1. 사용자가 인증된 상태에서 공격자가 요청을 조작하여 피해를 입히는 공격
    2. 방지대책
        - CSRF 토큰 사용
3. 토큰 탈취 방지
    1. 공격자가 사용자의 JWT, 세션토큰, API 키 등을 가로채어 인증을 우회하는 공격
        - HTTPS 사용
        - 토큰 만료 시간 설정
        - Refresh Token 사용
        

# ‼️ 예시 질문

## HTTP 자격증명 헤더가 웹 어플리케이션 보안에서 어떤 역할을 하는지 설명해주세요

HTTP 자격증명 헤더는 클라이언트가 서버에 인증 정보를 제공하는 방법입니다. 이때 사용자 인증, 보안 강화, API 보안의 역할을 합니다.

## WWW-Authenticate / Authorization 헤더의 차이점에 대해서 설명해주세요

WWW-Authenticate : 서버가 클라이언트에게 어떤 인증 방식을 사용할지 요구

Authorization : 클라이언트가 서버에 자격 증명을 포함하여 요청

## JWT가 어떤 구성 요소로 이루어져 있으며, 각 요소의 역할은 무엇인지 설명해주세요

1. 헤더 : 알고리즘과 타입 정보를 포함
2. 페이로드 : 사용자 정보 및 만료 시간 저장
3. 서명 : 토큰 위변조 방지를 위하여 데이터 무결성 검증

## JWT 검증시 서버에서 수행하는 주요 절차에 대해서 설명해주세요

1. 토큰 존재 여부 확인
2. 토큰 디코딩 및 구조 검증
3. 서버의 비밀키 / 공개키를 이용하여 서명 검증
4. 페이로드 클레임 유효성 검사
5. 인증 정보 활용

## Access Token과 Refresh Token 두 토큰의 차이와 각각의 역할, 그리고 토큰 갱신 시 고려해야 할 사항에 대해 설명해 주세요.

|  | Access Token | Refresh Token |
| --- | --- | --- |
| 역할 | API 요청 시 사용자 인증을 담당 | Access Token이 만료되었을 때 재발급 요청에 사용 |
| 저장위치 | 메모리, Authorization 헤더 | 보안이 강화된 저장소 (HttpOnly 쿠키, DB) |
| 유효기간 | 짧음 | 길다 |
| 재발급 필요 여부 | 만료 시 새로 받아야 함 | 만료 전까지 Access Token 갱신 가능 |
| 보안 위험 | 탈취하면 API 요청이 가능 | 탈취되면, Access Token 무제한 발급 가능 |

- 토큰 갱신 시 고려 사항

Access Token이 만료되면 Refresh Token을 사용해 재발급

Refresh Token은 HttpOnly, Secure 쿠키에 저장하여 XSS 공격 방지

## 왜 HTTPS가 토큰 기반 인증에서 필수적인지 설명해주세요

1. 토큰 탈취 방지
    1. HTTP에서는 Access Token이 평문으로 전송
    2. HTTPS는 TLS 암호화를 적용하여 데이터를 보호
2. 인증 정보 변조 방지
    1. HTTPS는 데이터 무결성을 보장하여 공격자가 JWT를 변조할 수 없도록 방어
3. 세션 하이재킹 방지
    1. 브라우저에서 Secure 플래그를 설정할 수 있어 쿠키를 안전하게 보호
4. 브라우저 보안 정책 적용 가능
    1. HTTPS에서는 SameSite, Secure, HttpOnly 속성을 활용

## JWT나 OAuth기반 인증에서 발생할 수 있는 보안 취약점 / 이를 보완하기 위한 대책에는 어떤 것들이 있는지 설명해주세요

| **보안 취약점** | **설명** | **보완 대책** |
| --- | --- | --- |
| **토큰 탈취 (Token Theft)** | 공격자가 Access Token/Refresh Token을 탈취하여 사용자로 위장 | - **HTTPS 필수 사용**- Refresh Token을 **HttpOnly 쿠키에 저장**- **MFA(다중 인증) 적용** |
| **JWT 탈취 후 재사용 (Replay Attack)** | 탈취된 JWT를 사용하여 무단으로 API 요청 | - `exp(만료 시간)`을 짧게 설정- **Refresh Token을 통한 재발급 구조 적용**- **IP 또는 User-Agent 검사** |
| **토큰 변조 공격** | 공격자가 JWT 서명을 제거하거나 위조하여 악의적인 요청 | - **RS256과 같은 비대칭 암호화 사용**- 서버에서 **Signature 검증 철저히 수행** |
| **CSRF (Cross-Site Request Forgery)** | 공격자가 사용자의 인증 정보를 가로채 API 요청을 대신 수행 | - **SameSite=Strict 쿠키 설정**- **CSRF 토큰 사용 (Stateful 방식 적용 가능)** |
| **XSS (Cross-Site Scripting) 공격** | 악성 스크립트가 실행되어 JWT가 탈취됨 | - **JWT를 브라우저 LocalStorage에 저장하지 않기**- **HttpOnly + Secure 쿠키 사용** |
| **Refresh Token 탈취** | Refresh Token이 유출되면 공격자가 Access Token을 무제한 생성 | - Refresh Token 사용 시 **재발급 시도 횟수 제한**- **로그아웃 시 Refresh Token 즉시 폐기** |

**보안성을 강화하려면?**

- **Access Token은 짧게, Refresh Token은 안전한 쿠키에 저장**
- **HTTPS 사용 & 서명 검증 필수**
- **JWT 탈취 가능성을 줄이기 위해 IP 기반 보안, MFA 적용 고려**